<!DOCTYPE html>
<html lang="pt">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Conexão com o Professor</title>
<style>
  body {
    margin: 0;
    background: #000;
    font-family: "Roboto", sans-serif;
    color: #fff;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: flex-start;
    height: 100vh;
    overflow: hidden;
  }
  .video-container {
    position: relative;
    width: 100vw;
    height: 100vh;
    display: flex;
    align-items: center;
    justify-content: center;
    overflow: hidden;
  }
  #remoteVideo {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    object-fit: contain;
    background: black;
  }
  #localVideo {
    position: absolute;
    bottom: 20px; right: 20px;
    width: 130px; height: 95px;
    border: 2px solid #fff;
    z-index: 3;
    border-radius: 8px;
    object-fit: cover;
    background: black;
  }
  #status {
    position: absolute;
    top: 10px; width: 100%;
    text-align: center; font-size: 16px;
    z-index: 4;
  }
</style>
</head>
<body>
  <div class="video-container">
    <video id="remoteVideo" autoplay playsinline></video>
  </div>
  <video id="localVideo" autoplay muted playsinline></video>
  <div id="status">🔎 Estabelecendo conexão segura...</div>

  <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>

  <script>
  const statusEl = document.getElementById("status");
  const localVideo = document.getElementById("localVideo");
  const remoteVideo = document.getElementById("remoteVideo");

  const aluno = "{{ aluno }}";
  const professor = "{{ professor }}";

  let peer, localStream, currentCall, reconnectTimer;
  let etapa = 1;

  // === 1️⃣ Inicializar Câmera com Qualidade Alta + Filtros ===
  async function startCamera() {
    try {
      localStream = await navigator.mediaDevices.getUserMedia({
        video: {
          width: { ideal: 1920 },
          height: { ideal: 1080 },
          frameRate: { ideal: 60, max: 60 },
          facingMode: "user"
        },
        audio: {
          echoCancellation: true,
          noiseSuppression: true,
          autoGainControl: true,
          latency: 0,
          channelCount: 2
        }
      });
      localVideo.srcObject = localStream;
      return true;
    } catch (err) {
      console.error("Erro ao acessar câmera/microfone:", err);
      statusEl.textContent = "❌ Falha ao iniciar câmera/microfone";
      return false;
    }
  }

  // === 2️⃣ Otimizar parâmetros de transmissão ===
  function otimizarStream(peerConnection) {
    const senders = peerConnection.getSenders();
    senders.forEach(sender => {
      if (sender.track && sender.track.kind === "video") {
        const params = sender.getParameters();
        if (!params.encodings) params.encodings = [{}];
        params.encodings[0].maxBitrate = 3_000_000; // 3 Mbps
        params.encodings[0].minBitrate = 800_000;
        params.encodings[0].maxFramerate = 60;
        sender.setParameters(params).catch(() => {});
      }
    });
  }

  // === 3️⃣ Inicializar Peer com ICE/TURN avançado ===
  function initPeerAndConnect(peerIdDoProfessor) {
    peer = new Peer({
      config: {
        iceServers: [
          { urls: "stun:stun.l.google.com:19302" },
          { urls: "stun:global.stun.twilio.com:3478?transport=udp" },
          { urls: "stun:stun1.l.google.com:19302" },
          { urls: "turn:openrelay.metered.ca:80", username: "openrelayproject", credential: "openrelayproject" },
          { urls: "turn:openrelay.metered.ca:443?transport=tcp", username: "openrelayproject", credential: "openrelayproject" },
          { urls: "turn:turn.anyfirewall.com:443?transport=tcp", username: "webrtc", credential: "webrtc" }
        ],
        iceTransportPolicy: "all"
      },
      debug: 1
    });

    peer.on("open", () => {
      statusEl.textContent = "🔗 Conectando ao professor...";
      currentCall = peer.call(peerIdDoProfessor, localStream, { metadata: { role: "aluno" } });
      handleCallEvents(currentCall);
    });

    peer.on("error", err => {
      console.error("Erro PeerJS:", err);
      statusEl.textContent = "⚠️ Problema na conexão. Tentando reconectar...";
      tentarReconectar();
    });
  }

  // === 4️⃣ Gerenciar chamada e qualidade ===
  function handleCallEvents(call) {
    currentCall = call;

    call.on("stream", async (remoteStream) => {
      remoteVideo.srcObject = remoteStream;
      await remoteVideo.play().catch(() => console.warn("⚠️ Clique para liberar áudio"));
      statusEl.textContent = `🟢 Conectado (Etapa ${etapa}/3)`;

      const pc = call.peerConnection;
      if (pc) otimizarStream(pc);
      monitorarConexao(pc);
      iniciarCronometroAula();
    });

    call.on("iceconnectionstatechange", () => {
      const state = call.peerConnection?.iceConnectionState;
      if (["failed", "disconnected"].includes(state)) {
        statusEl.textContent = "🔄 Reconectando automaticamente...";
        tentarReconectar();
      }
    });

    call.on("close", () => {
      statusEl.textContent = "🔴 Conexão encerrada.";
    });

    call.on("error", (err) => {
      console.error("Erro de chamada:", err);
    });
  }

  // === 5️⃣ Monitorar a qualidade da conexão ===
  function monitorarConexao(pc) {
    if (!pc) return;
    setInterval(async () => {
      const stats = await pc.getStats();
      stats.forEach(report => {
        if (report.type === "outbound-rtp" && report.kind === "video") {
          if (report.packetsLost > 10) {
            statusEl.textContent = "📶 Rede instável... ajustando bitrate...";
            const sender = pc.getSenders().find(s => s.track?.kind === "video");
            if (sender) {
              const params = sender.getParameters();
              if (!params.encodings) params.encodings = [{}];
              params.encodings[0].maxBitrate = 1_500_000; // reduz temporariamente
              sender.setParameters(params).catch(()=>{});
            }
          }
        }
      });
    }, 3000);
  }

  // === 6️⃣ Reconexão inteligente ===
  function tentarReconectar() {
    clearTimeout(reconnectTimer);
    reconnectTimer = setTimeout(async () => {
      if (currentCall?.peer && localStream) {
        const newCall = peer.call(currentCall.peer, localStream);
        handleCallEvents(newCall);
      } else {
        await buscarPeerIdEDiscar();
      }
    }, 2000);
  }

  // === 7️⃣ Buscar ID do professor ===
  async function buscarPeerIdEDiscar() {
    try {
      const alunoNormalizado = aluno.trim().toLowerCase().replace(/\s/g, "");
      const res = await fetch(`/buscar-id-professor?aluno=${alunoNormalizado}`);
      const data = await res.json();
      if (data.peer_id) {
        initPeerAndConnect(data.peer_id);
      } else {
        statusEl.textContent = "⏳ Aguardando o professor...";
        setTimeout(buscarPeerIdEDiscar, 3000);
      }
    } catch (err) {
      console.error("Erro ao buscar ID:", err);
    }
  }

  // === 8️⃣ Cronômetro e intervalos ===
  function iniciarCronometroAula() {
    let tempoRestante = 1260;
    const cron = setInterval(() => {
      tempoRestante--;
      if (tempoRestante <= 0) {
        clearInterval(cron);
        encerrarEtapa();
      }
    }, 1000);
  }

  function encerrarEtapa() {
    try { currentCall?.close(); } catch(_) {}
    remoteVideo.srcObject = null;
    if (etapa < 3) {
      etapa++;
      statusEl.textContent = "⏱️ Intervalo de 5 minutos...";
      setTimeout(iniciarReconexaoAposIntervalo, 300000);
    } else {
      statusEl.textContent = "✅ Aula finalizada.";
    }
  }

  function iniciarReconexaoAposIntervalo() {
    statusEl.textContent = "🔄 Reconectando...";
    buscarPeerIdEDiscar();
  }

  // === 9️⃣ Iniciar tudo ===
  startCamera().then(ok => {
    if (ok) buscarPeerIdEDiscar();
  });
  </script>
</body>
</html>
